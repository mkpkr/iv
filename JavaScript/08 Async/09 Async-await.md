There’s a special syntax to work with promises in a more comfortable fashion, called “async/await”. It’s surprisingly easy to understand and use.

Async Functions

The word “async” before a function means one simple thing: the function always returns a promise. Other values are wrapped in a resolved promise automatically.

For instance, this function returns a resolved promise with the result of 1; let’s test it:

async function f() {
  return 1;
}

f().then(alert); // 1

await works only inside async functions, it makes JavaScript wait until that promise settles and returns its result.

let value = await promise;

await literally suspends the function execution until the promise settles, and then resumes it with the promise result. That doesn’t cost any CPU resources, because the JavaScript engine can do other jobs in the meantime: execute other scripts, handle events, etc.

async function showAvatar() {
 
  // read our JSON
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();
 
  // read github user
  let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
  let githubUser = await githubResponse.json();
 
  // show the avatar
  let img = document.createElement('img');
  img.src = githubUser.avatar_url;
  img.className = "promise-avatar-example";
  document.body.append(img);
 
  // wait 3 seconds
  await new Promise((resolve, reject) => setTimeout(resolve, 3000));
 
  img.remove();
 
  return githubUser;
}
 
showAvatar();


Async Class Methods

class Waiter {
  async wait() {
    return await Promise.resolve(1);
  }
}
 
new Waiter()
  .wait()
  .then(alert); // 1 (this is the same as (result => alert(result)))


Error Handling

If a promise resolves normally, then await promise returns the result. But in the case of a rejection, it throws the error, just as if there were a throw statement at that line.
 
We can catch that error using try..catch, the same way as a regular throw:
 
async function f() {
 
  try {
    let response = await fetch('http://no-such-url');
  } catch(err) {
    alert(err); // TypeError: failed to fetch
  }
}
 
f();
 
 
 If we don’t have try..catch, then the promise generated by the call of the async function f() becomes rejected. We can append .catch to handle it:
 
async function f() {
  let response = await fetch('http://no-such-url');
}
 
// f() becomes a rejected promise
f().catch(alert); // TypeError: failed to fetch

If we forget to add .catch there, then we get an unhandled promise error (viewable in the console). We can catch such errors using a global unhandledrejection event handler as described in Promise Error Handling 


async/await vs promise.then/catch

When we use async/await, we rarely need .then, because await handles the waiting for us. And we can use a regular try..catch instead of .catch. 

That’s usually more convenient. But at the top level of the code, when we’re outside any async function, we’re syntactically unable to use await, so it’s a normal practice to add .then/catch to handle the final result or falling-through error.


async/await and Promise.all

When we need to wait for multiple promises, we can wrap them in Promise.all and then await:
 
// wait for the array of results
let results = await Promise.all([
  fetch(url1),
  fetch(url2),
  ...
]);

In the case of an error, it propagates as usual, from the failed promise to Promise.all, and then becomes an exception that we can catch using try..catch around the call.

