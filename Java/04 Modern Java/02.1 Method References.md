# Method References

Method references let you reuse existing method definitions and pass them like lambdas. In some cases they appear more readable and feel more natural than using lambda expressions. There are three main kinds of method references:

1. A method reference to a static method
	- `Integer::parseInt`
	- `System.out::println`
	- `Thread::dumpStack`

2. A method reference to an instance method of an arbitrary type
	- `Apple::getWeight`
	- `String::substring`

3. A method reference to an instance method of an existing object or expression
	- `expensiveTransaction::getValue`
	- `this::isValidName`

- For 1 & 3, the referenced method must have the same signature as the functional interface's function descriptor.
- For 2, they must almost match, except the function descriptor of the functional interface must have as its first argument the type that contains the instance method.
	- The idea with this kind of method references, such as String::length, is that youâ€™re referring to a method to an object that will be supplied as one of the parameters of the lambda.

![[Pasted image 20250904203332.png]]

- (2) example:

```java
//StringChanger.java
@FunctionalInterface
interface StringChanger {
    String changeString(String s);
}
 
//Service.java
public void doSomething(StringChanger sc) {
    System.out.println(sc.changeString("mike");
}
```
This can be called using the following:

```java
Service service = new Service;
service.doSomething(s -> s.toUpperCase());
//or
service.doSomething(String::toUpperCase);
```

Both match the functional interface signature: String changeString(String s);


- (3) is particularly useful when you need to pass around a method defined as a private helper. 

For example, say you defined a helper method isValidName:
 
```java
private boolean isValidName(String string) {
    return Character.isUpperCase(string.charAt(0));
}
```

You can now pass this method around in the context of a Predicate using a method reference: 

```java
filter(words, this::isValidName);
```


