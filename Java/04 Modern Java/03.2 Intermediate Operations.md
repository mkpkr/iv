# Create

- `{java} static Stream<T> of(T... values)`
- `{java} static Stream<T> of(T t)`

- `{java} static Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)`

- `{java} static Stream<T> empty()`

- `{java} static Stream<T> generate(Supplier<T> s)`

```java
 static Stream<T> iterate(T seed,
                         UnaryOperator<T> f)
```

```java
 static Stream<T> iterate(T seed,
                         Predicate<? super T> hasNext,
                         UnaryOperator<T> next)
```

## of()

```java
Stream<String> stream = Stream.of("Modern ", "Java ", "In ", "Action");
```

## iterate()

In general, you should use iterate when you need to produce a sequence of sucessive values (for example) a date followed by its next date. iterate can produce an infinite stream if not limited:

```java
Stream.iterate(0, n -> n+2)
      .limit(10)
      .forEach(System.out::println)
```

Java 9 saw iterate get support for a Predicate to stop the iteration:

```java
IntStream.iterate(0, n -> n < 100, n -> n + 4);
```

Note you cannot get the same effect with a filter because the filter would have no idea that the numbers continue to increase.

You could however solve the problem with takeWhile.

## generate()

The generate method lets you produce an infinite stream like iterate, but it doesn't apply successively a function on each new produced value. It takes a lambda of type `Supplier<T>` to produce new values:

```java
Stream.generate(Math::random)
      .limit(5)
      .forEach(System.out::println);
```

A supplier doesn’t have to be stateless. You can create a supplier that stores state that it can modify and use when generating the next value of the stream.

# Transform

- `{java} Stream<T> distinct()`

- `{java} Stream<T> filter(Predicate<? super T> predicate)`

- `{java} Stream<T> limit(long maxSize)`

- `{java} Stream<T> skip(long n)`

- `{java} Stream<T> sorted()`
- `{java} Stream<T> sorted(Comparator<? super T> comparator)`

- `{java} Stream<T> dropWhile(Predicate<? super T> predicate)`
- `{java} Stream<T> takeWhile(Predicate<? super T> predicate)`

# Map

- `{java} Stream<R>     map(Function<? super T,? extends R> mapper)`

- `{java} DoubleStream  mapToDouble(ToDoubleFunction<? super T> mapper)`
- `{java} IntStream     mapToInt(ToIntFunction<? super T> mapper)`
- `{java} LongStream    mapToLong(ToLongFunction<? super T> mapper)`

# Flat Map

- `{java} Stream<R>    flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)`

- `{java} DoubleStream flatMapToDouble(Function<? super T, ? extends DoubleStream> mapper)`
- `{java} IntStream    flatMapToInt(Function<? super T, ? extends IntStream> mapper)`
- `{java} LongStream   flatMapToLong(Function<? super T, ? extends LongStream> mapper)`

# map vs flatMap

`map` will return a Stream of whatever its Function return type is, if a function returns `Stream<String>`, then we get `Stream<Stream<String>>`

What we want is `<Stream<String>`

`flatMap` expects the return type of its function to be a `Stream<something>`, and instead of returning` Stream<Stream<something>>` it just returns `Stream<something>`