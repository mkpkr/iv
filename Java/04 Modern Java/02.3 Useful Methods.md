# Compartor.comparing()

Comparator includes a static helper method called comparing that takes a Function extracting a Comparable key and produces a Comparator object.
 
```java
import static java.util.Comparator.comparing;

inventory.sort(comparing(apple -> apple.getWeight()));
//or
inventory.sort(comparing(Apple::getWeight));
```


## Composing Comparators


### `reversed()`

Sort apples by decreasing weight
 
```java
inventory.sort(comparing(Apple::getWeight).reversed());
```

### `thenComparing()`

What if you find two apples that have the same weight?
 
```java
inventory.sort(comparing(Apple::getWeight)
              .reversed()  
              .thenComparing(Apple::getCountry));
```


# Composing Predicates

## `negate()`

```java
Predicate<Apple> notRedApple = redApple.negate();
```

## `and()`

```java
Predicate<Apple> redAndHeavyApple = redApple.and(apple -> apple.getWeight() > 150);          
```
## `or()`

```java
Predicate<Apple> redAndHeavyAppleOrGreen = 
                          redApple.and(apple -> apple.getWeight() > 150)         
                                  .or(apple -> GREEN.equals(a.getColor()));      
```   

Note that the precedence of methods and and or in the chain is from left to right—there is no equivalent of bracketing.
	• So **`a.or(b).and(c)`** must be read as **`(a || b) && c`**.
	• Similarly, **`a.and(b).or(c)`** must be read as as **`(a && b) || c`**


# Composing Functions

## `andThen()`
 
Apply this function, and then the function in the argument to andThen()

```java
Function<String, String> addHeader = Letter::addHeader;

Function<String, String> transformationPipeline = addHeader
                                                 .andThen(Letter::checkSpelling)              
                                                 .andThen(Letter::addFooter);
```

## `compose()`

Apply the function in the argument to compose() first, and then the fucntion compose was called on.
