Always use the most specialised/concise solution to solve your problem:

- favour the convenience methods on a stream (`max`, `min`, `count` etc)
- use reduce when the result is an immutable value
- use a predefined collector (`toList`, `groupingBy` etc) when the result is a mutable object or container
- use `Collectors.reducing` or a custom collector for more complex tasks

# Find or Match

Short circuit operations, don't need to process the whole collection

- `{java} Optional<T> findAny()`
- `{java} Optional<T> findFirst()`

- `{java} boolean allMatch(Predicate<? super T> predicate)`
- `{java} boolean anyMatch(Predicate<? super T> predicate)`
- `{java} boolean noneMatch(Predicate<? super T> predicate)`

`findFirst` doesn't parallelise very well, use `findAny` if you don't care which element is returned

# Collect

```java
R collect(Collector<? super T,A,R> collector)
```

```java
R collect(Supplier<R> supplier,
          BiConsumer<R,? super T> accumulator,
          BiConsumer<R,R> combiner)
```

See Collect vs Reduce

# Iterate

- `{java} void forEach(Consumer<? super T> action)`
- `{java} void forEachOrdered(Consumer<? super T> action)`

# Max/Min

- `{java} Optional<T> max(Comparator<? super T> comparator)`
- `{java} Optional<T> min(Comparator<? super T> comparator)`

# Count

- `{java} long count()`

# Reduce

```java
T reduce(T identity,
         BinaryOperator<T> accumulator)
```

```java
Optional<T> reduce(BinaryOperator<T> accumulator)
```

```java
U reduce(U identity,
         BiFunction<U,? super T,U> accumulator,
         BinaryOperator<U> combiner)
```

Such queries combine all the elements in the stream repeatedly to produce a single value such as an Integer.

These queries can be classified as reduction operations (a stream is reduced to a value).

**Note that the result of a reduce is the same type as the type of the stream.**

See Collect vs Reduce

## Summing

You can sum all the elements of a stream as follows:

```java
int sum = numbers.stream()
                 .reduce(0, (a, b) -> a + b);
```

This version of reduce takes two arguments: An initial value and a `BinaryOperator` to combine two elements and produce a new value. Here a is the accumulated value, and b is the next value in the stream.

![[Pasted image 20250904205427.png]]
You can make this code more concise by using a method reference. From Java 8 the Integer class now comes with a static sum method to add two numbers:

```java
int sum = numbers.stream().reduce(0, Integer::sum);
```

There’s also an overloaded variant of reduce that doesn’t take an initial value, but it returns an Optional object:

```java
Optional<Integer> sum = numbers.stream().reduce((a, b) -> (a + b));
```

Also see `IntStream`/`LongStream`/`DoubleStream.sum`

Also see `Collectors.summingInt`/`summingLong`/`summingDouble`

## Max/Min

```java
Optional<Integer> max = numbers.stream().reduce(Integer::max);
```

You could have equally well used the lambda (x, y) -> x > y ? x : y instead of Integer::max, but the latter is definitely easier to read.

Finds the transaction with the smallest value:

```java
Optional<Transaction> smallestTransaction =
        transactions.stream()
                    .reduce((t1, t2) -> t1.getValue() < t2.getValue() ? t1 : t2);
```

See earlier section on Max/Min for simpler way of handling these examples

Can also do this with Collectors.maxBy and Collectors.minBy

# toArray

- `{java} Object[] toArray()`
- `{java} A[]      toArray(IntFunction<A[]> generator)`

# Collect vs Reduce

Note that reduce produces a value which is the same type as the stream. So a stream of Dish elements could not be reduced to a total caloric value without first being mapped to `Integer` - `map(Dish::getCalories)`, or better mapped to `int` – `mapToInt(Dish::getCalories)`. This is a key difference between reduce and collect – collect can accumulate values to an arbitrary type.

Another difference is:

- collect() can only work with **mutable** result objects.
- reduce() is designed to work with **immutable** result objects.

The normal reduction is meant to combine two immutable values such as int, double etc. and produce a new one; it’s an immutable reduction.

In contrast, the collect method is designed to mutate a container to accumulate the result it’s supposed to produce.