# 1. Collecting

Typically, the Collector applies a transforming function to the element. Quite often this is the identity transformation, which has no effect (for example, as in toList).
 
Note that in this document there are uses of collectors that could be done with reduce(), see Collect vs Reduce in Terminal Operations for information on when to use which.
 
- `{java} toList()
- `{java} toSet()
- `{java} toCollection(Supplier<C> collectionFactory)

- `{java} toUnmodifiableList()
- `{java} toUnmodifiableSet()

- `{java} toMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper)
- `{java} toMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction)
- `{java} toMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction, Supplier<M> mapFactory)

- `{java} toConcurrentMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper)
- `{java} toConcurrentMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction)
- `{java} toConcurrentMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction, Supplier<M> mapFactory)

- `{java} toUnmodifiableMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper)
- `{java} toUnmodifiableMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction)

- `{java} collectingAndThen(Collector<T,A,R> downstream, Function<R,RR> finisher)


# 2. Grouping

- `{java} groupingBy(Function<? super T,? extends K> classifier)
- `{java} groupingBy(Function<? super T,? extends K> classifier, Collector<? super T,A,D> downstream)
- `{java} groupingBy(Function<? super T,? extends K> classifier, Supplier<M> mapFactory, Collector<? super T,A,D> downstream)
- `{java}  
- `{java} groupingByConcurrent(Function<? super T,? extends K> classifier)
- `{java} groupingByConcurrent(Function<? super T,? extends K> classifier, Collector<? super T,A,D> downstream)
- `{java} groupingByConcurrent(Function<? super T,? extends K> classifier, Supplier<M> mapFactory, Collector<? super T,A,D> downstream)
- `{java}  
- `{java} partitioningBy(Predicate<? super T> predicate)
- `{java} partitioningBy(Predicate<? super T> predicate, Collector<? super T,A,D> downstream)
 
- Downstream collectors
	- `{java} filtering(Predicate<? super T> predicate, Collector<? super T,A,R> downstream)
	- `{java} mapping(Function<? super T,? extends U> mapper, Collector<? super U,A,R> downstream)
	- `{java} flatMapping(Function<? super T,? extends Stream<? extends U>> mapper, Collector<? super U,A,R> downstream)

The parameter named “downstream” takes a second collector for further manipulation/collection. Note that the collectors from the next section Reducing & Summarizing can also be used here.


## Simple Grouping

```java
Map<Dish.Type, List<Dish>> dishesByType 
        = menu.stream().collect(groupingBy(Dish::getType));
```

```java
public enum CaloricLevel { DIET, NORMAL, FAT }
Map<CaloricLevel, List<Dish> dishesByCaloricLevel = menu.stream().collect(
        groupingBy(dish -> {
                 if (dish.getCalories() <= 400) return CaloricLevel.DIET;                  
                 else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;                 
                 else return CaloricLevel.FAT;          
        } ));
```

## Manipulating After Grouping (Downstream Collectors)

Frequently after performing a grouping operation you may need to manipulate the elements in each resulting group.
 
### Filtering

```java
Map<Dish.Type, List<Dish>> caloricDishesByType = menu.stream().collect(
        groupingBy(Dish::getType,
                   filtering(dish -> dish.getCalories() > 500, toList())));
```

### Mapping

```java
Map<Dish.Type, List<String>> dishNamesByType = menu.stream().collect(
        groupingBy(Dish::getType,
                   mapping(Dish::getName, toList())));
```

### Flat Mapping

Suppose that we have a Map associating to each dish a list of tags as it follows:
 
```java
Map<String, List<String>> dishTags = new HashMap<>();

dishTags.put("pork", asList("greasy", "salty"));
dishTags.put("salmon", asList("delicious", "fresh"));
//etc...
```

Extract these tags for each group of type of dishes using the `flatMapping` Collector:
 
```java
Map<Dish.Type, Set<String>> dishTagsByType = menu.stream().collect(
        groupingBy(Dish::getType,
                   flatMapping(dish -> dishTags.get(dish.getName()).stream(), toSet())));
```


## Multilevel Grouping

The two argument Collectors.groupingBy can also be used also to perform a two-level grouping.
 
To achieve this you can pass to it a second inner `groupingBy` to the outer `groupingBy`
 
```java
Map<Dish.Type, Map<CaloricLevel, List<Dish>>> dishesByTypeCaloricLevel =
    menu.stream().collect(
        groupingBy(Dish::getType,
                   groupingBy(dish -> {  
                         if (dish.getCalories() <= 400)
                             return CaloricLevel.DIET;                  
                         else if (dish.getCalories() <= 700)
                             return CaloricLevel.NORMAL;
                         else
                             return CaloricLevel.FAT;           
                   } )       
        )
);
```

This multilevel grouping operation can be extended to any number of levels.

# 3. Reducing & Summarizing (Downstream Collectors)

These will primarily be used in downstream collectors as there are equivalent `Stream`/`IntStream` etc methods for use on a main stream.
 
- `{java} counting()

- `{java} maxBy(Comparator<? super T> comparator)
- `{java} minBy(Comparator<? super T> comparator)

- `{java} summingInt(ToIntFunction<? super T> mapper)
- `{java} summingLong(ToLongFunction<? super T> mapper)
- `{java} summingDouble(ToDoubleFunction<? super T> mapper)

- `{java} averagingInt(ToIntFunction<? super T> mapper)
- `{java} averagingLong(ToLongFunction<? super T> mapper)
- `{java} averagingDouble(ToDoubleFunction<? super T> mapper)

- `{java} summarizingInt(ToIntFunction<? super T> mapper)
- `{java} summarizingLong(ToLongFunction<? super T> mapper)
- `{java} summarizingDouble(ToDoubleFunction<? super T> mapper)

- `{java} joining()
- `{java} joining(CharSequence delimiter)
- `{java} joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)

- `{java} reducing(BinaryOperator<T> op)
- `{java} reducing(T identity, BinaryOperator<T> op)
- `{java} reducing(U identity, Function<? super T,? extends U> mapper, BinaryOperator<U> op)

## Counting

You could write:
 
```java
long howManyDishes = menu.stream().collect(Collectors.counting());
```

But the -ing functions should be used for downstream collectors. You can write this far more directly as:

```java
long howManyDishes = menu.stream().count();
```

## Max/Min

Suppose you want to find the highest/lowest calorie dish in the menu.
 
Easiest way to do this is to use Stream max(comparator)/min(comparator)
 
But it can also be done in a collector using Collectors.maxBy and Collectors.minBy to calculate the maximum or minimum value in a stream. These two collectors take a Comparator as argument to compare the elements in the stream.
 
```java
Comparator<Dish> dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories);
Optional<Dish> highestCalorieDish = menu.stream()
                                        .collect(maxBy(dishCaloriesComparator));
```

Collectors.minBy/maxBy would most likely be used in a downstream collector as we can use Stream.max/min in the above situation.
 
## Summing

The Collectors class provides a specific factory method for summing: Collectors.summingInt
 
It accepts a function that maps an object into the int that has to be summed
 
```java
int totalCalories = menu.stream()
                        .collect(summingInt(Dish::getCalories));
```

Collectors.summingLong and Collectors.summingDouble behave exactly the same way.

## Averaging

```java
double avgCalories = menu.stream()
                         .collect(averagingInt(Dish::getCalories));
```

## Summarization

Quite often, though, you may want to retrieve two or more of sum, average, maximum, and minimum, and possibly you’d like to do it in a single operation.
 
```java
IntSummaryStatistics menuStats = menu.stream()
                                     .collect(summarizingInt(Dish::getCalories));
```

As usual, there are corresponding summarizingLong and summarizingDouble factory methods with associated types LongSummaryStatistics and DoubleSummaryStatistics.
 
## Joining Strings

```java
String shortMenu = menu.stream()
                       .map(Dish::getName)
                       .collect(joining());
```

Note that joining internally makes use of a StringBuilder to append the generated strings into one.
 
Also note that if the Dish class had a toString method returning the dish’s name, you’d obtain the same result without needing to map over the original stream with a function extracting the name from each dish:
 
```java
String shortMenu = menu.stream()
                       .collect(joining());
```

The joining factory method is overloaded, with one of its overloaded variants taking a string used to delimit two consecutive elements, and the other taking delimiter, prefix and suffix.
 `
```java
String shortMenu = menu.stream()
                       .map(Dish::getName)
                       .collect(joining(", "));
```

## Generalised Reduction

All the collectors we’ve discussed so far are only convenient specializations of a reduction process that can be defined using the reducing factory method.
 
For instance, it’s possible to calculate the total calories in your menu with a collector created from the reducing method as follows:
 
```java
int calories = menu.stream()
                   .collect(reducing(0, Dish::getCalories, (i, j) -> i + j));
```

(Or can use Integer::sum for third argument)
  
There is a one argument version which just takes a BinaryOperator and returns an Optional:
 
```java
Optional<Dish> mostCalDish = menu.stream()
                                 .collect(reducing((d1, d2) -> d1.getCalories() > d2.getCalories() ? d1 : d2));
```

Remember reducing takes a `BinaryOperator<T>` to aggregate items, which is a `BinaryFunction<T,T,T>` meaning the items being operated on have to match the return type.


